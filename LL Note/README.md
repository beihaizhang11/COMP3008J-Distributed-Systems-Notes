# 分布式系统课程笔记

# Week 1

## 1. 什么是分布式系统？

- 分布式系统是由**多个独立计算机**组成的系统，它们通过网络通信与协调，向用户表现为一个单一系统。
- 分布式系统的两种类型：
    - **松散耦合**系统（如互联网）：各个组件相对独立。
    - **紧密耦合**系统（如多处理器系统）：组件之间依赖性强。

### 定义：
- 分布式系统是一个**硬件或软件**组成的系统，位于多个网络计算机上，通过**消息传递**进行通信和协调。

---

## 2. 为什么使用分布式系统？

- **目标**：通过一种透明、开放和可扩展的方式连接用户和资源。
    - **透明性**：用户不需要知道资源的实际位置或系统的内部结构。
    - **开放性**：系统允许在运行时添加或移除资源。
    - **可扩展性**：系统可以应对用户和资源数量的增加。

---

## 3. 分布式系统的示例

- **互联网**：全球计算机网络的集合，设备之间通过消息传递实现交互，用户可以访问服务（如Web资源）。
- **移动计算**：如“Bump”应用程序，通过云服务器和GPS进行数据交换，支持分布式协作。

---

## 4. 术语解释

- **站点（Site）**：分布式系统中的一个地理位置，包含一个或多个主机。
- **主机（Host）**：连接到分布式系统中的具体机器（节点）。
- **客户端（Client）**：访问并使用服务器资源。
- **服务器（Server）**：提供资源或服务。
- **资源（Resource）**：程序、数据、文件等，可能存储在不同主机上。
- **任务（Task）**：用户请求分布式系统执行的一组指令。

---

## 5. 分布式系统的好处、问题和挑战

- **资源共享**：各节点可以共享彼此的资源，如文件、打印机等。
- **并发性**：多个用户可以并行工作，系统需要处理并发任务。
- **全球时间**：某些任务需要统一的时间概念，如银行系统中的交易。
- **可靠性**：分布式系统可以通过冗余实现容错，即使一个节点失效，其他节点仍能正常工作。
- **可扩展性**：系统需要能够应对用户和资源数量的增长。

---

## 6. 资源共享

- 各个节点可以访问其他节点的资源，提升资源的利用率。
- **问题**：
    - 如何控制资源的访问权限？
    - 当资源不可用时，系统如何处理？

---

## 7. 并发性

- 系统必须能够处理多个任务同时进行的情况（如多个用户同时访问同一网站）。
- **问题**：
    - 太多用户可能会导致资源过载。
    - 并发操作带来额外的管理和通信开销。

---

## 8. 全球时间

- **挑战**：分布式系统中没有全局时钟。
- **问题**：
    - 不同节点的时钟可能不同步，影响任务顺序的正确性。
    - 解决方案：使用**逻辑时钟**（如Lamport时钟）来排序事件。

---

## 9. 可靠性

- **容错性**：即使某个节点失效，系统其他部分仍能继续运行。
- **冗余**：通过在多个节点复制资源来提高系统的可靠性。
- **问题**：设计和实现冗余机制增加了系统复杂性。

---

## 10. 可扩展性

- 系统需要能够处理用户和资源数量的增加。
- **问题**：
    - 新增节点的资源是否足够？
    - 新节点的加入可能导致网络流量增加。

---

## 11. 异构性

- 分布式系统需要支持不同类型的硬件、操作系统和编程语言。
- **挑战**：不同设备和语言之间的数据编码差异。

---

## 12. 开放性

- **开放性**：系统可以方便地添加和集成新服务。
- **要求**：公开关键软件接口，并定义统一的通信机制。

---

## 13. 安全性

- **信息传输安全**：加密数据以防止拦截和篡改（如SSL/TLS）。
- **访问控制安全**：确保只有授权用户可以访问系统资源（身份验证）。

---

## 14. 故障处理

- **故障检测**：系统需要能够识别某个节点或资源的故障。
- **故障掩盖**：通过冗余和备份来掩盖故障，使得其他节点不受影响。
- **故障恢复**：系统能够从故障中恢复，并恢复正常状态。

---

## 15. 透明性

- **访问透明性**：本地和远程资源的访问方式相同。
- **位置透明性**：用户不需要知道资源的物理位置。
- **并发透明性**：多个进程可以共享资源而不相互干扰。
- **复制透明性**：多个资源副本的存在对用户是透明的。
- **故障透明性**：故障时系统仍然能完成任务。
- **扩展透明性**：系统可以扩展规模而不影响结构。

---

## 16. 系统模型

- 分布式系统应设计为能够适应各种使用场景和工作负载。
- **挑战**：处理多样的系统环境、内部问题（如时钟不同步、数据冲突）、外部威胁（如安全攻击）。

---

## 17. 体系结构模型

- **服务器进程**：提供服务的组件。
- **客户端进程**：使用服务的组件。
- **对等进程**：协作完成任务的对等进程。

---

## 18. 软件架构模型

- **平台**：提供操作系统和底层资源。
- **中间件**：隐藏异构性，提供统一的编程接口。
- **应用程序和服务**：为用户提供具体的功能。

---

## 19. 中间件

- **定义**：中间件是分布式系统中的一层抽象，提供通信和资源共享支持。
- **功能**：
    - 远程方法调用（RMI）
    - 进程间通信
    - 事件通知
    - 数据分区和放置
    - 实时多媒体传输

---

## 20. 中间件的局限性

- **假设**：中间件假设所有通信操作都是原子性的，但实际应用可能需要更细粒度的控制。
- **端到端论点**：一些功能（如错误检测）必须在应用层实现，中间件无法完全提供这些功能。

---

## 21. 中间件的进一步局限性

- **端到端论点的总结**：有些功能需要应用层的参与，通信系统本身的检查是不够的。
- **功能冗余**：各层次上的功能重复增加了系统的复杂性。

---

## 22. 总结

- 分布式系统具有诸多优点，如资源共享、并发处理、容错性和可扩展性。
- 但同时也面临诸多挑战，包括全球时间的管理、可靠性、安全性和系统的复杂性。
- 中间件作为分布式系统的重要组成部分，为应用开发者提供了便利，但其局限性也需要通过应用层的设计来克服。

# Week2

## 2. 核心系统架构 - Client-Server
- **Client-Server模型**：客户端进程与服务器进程交互，服务器管理共享资源。
- **特点**：
    - 客户端发出请求，服务器处理并返回结果。
    - 服务器也可以充当其他服务器的客户端。

**例子**：
- **万维网（World Wide Web）**：Web浏览器（客户端）请求Web服务器，服务器处理并返回网页。

---

## 3. 核心系统架构 - Client-Server（Web交互示例）
- **Web浏览器**作为客户端，向Web服务器发送请求。
- **Web服务器**通过Servlet容器处理动态请求，返回结果。

---

## 4. 核心系统架构 - Peer-to-Peer
- **Peer-to-Peer模型（P2P）**：所有节点（Peer）角色相似，彼此协作完成任务，无固定客户端或服务器。
- 每个节点既是资源的提供者，又是资源的请求者。

**例子**：
- **Gnutella文件共享服务**：所有节点可以同时提供和消费资源。

---

## 5. 变体系统架构 - 多服务器提供服务
- **多服务器服务**：多个服务器分担任务，协同为客户端提供服务。
    - 服务器可以将服务基于的对象集划分，或在多个服务器上保持对象的副本。

**例子**：
- **在线书店服务**：
    1. **Store Front**：浏览库存。
    2. **Checkout**：处理购买交易。

---

## 6. 变体系统架构 - 代理服务器与缓存
- **缓存**：存储最近使用的对象，减少每次访问远程服务器的需求。
    - 如果缓存中有最新副本，则直接返回；否则从服务器获取并存储到缓存中。

- **代理服务器（Proxy）**：代理客户端与服务器之间的通信，减少直接访问服务器的负载。

---

## 7. 变体系统架构 - 移动代码
- **移动代码**：可以从一台计算机发送到另一台计算机并在目标机器上执行的代码。
- **例子**：Java Applets，下载并在Web浏览器中运行。

**优点**：
- 增强客户端功能，提升交互性能。

**问题**：
- **安全性**：需要控制移动代码在本地执行的权限，避免恶意活动。

---

## 8. 变体系统架构 - 网络计算机（Network Computers）
- **网络计算机（NC）**：极简的计算机，操作系统和应用程序从远程服务器下载。
- **优点**：
    - 减少硬件成本，降低技术维护要求。

- **问题**：
    - 对网络依赖性强，网络中断会影响工作效率。

---

## 9. 变体系统架构 - 瘦客户端（Thin Clients）
- **瘦客户端**：本地运行窗口化用户界面，但应用程序在远程服务器上执行。
- **问题**：
    - 网络中断会导致数据丢失，界面更新速度受网络延迟影响。

**例子**：
- **X-11窗口系统**：UNIX系统的窗口管理服务，客户端通过远程过程调用与窗口服务器交互。

---

## 10. 分布式系统设计要求 - 性能问题
- **响应性**：应用程序的响应速度会受到服务器负载、网络延迟、中间件服务开销等因素影响。

**优化**：
- 减少软件层次和客户端与服务器之间的数据传输量，提升响应速度。

---

## 11. 性能问题 - 吞吐量
- **吞吐量**：完成计算任务的速度，影响任务完成时间。
- **负载平衡**：通过将任务分配到多个服务器来提升系统整体性能。

---

## 12. 服务质量（QoS）
- **服务质量**衡量系统的可靠性、安全性和性能。
- 系统需要具备**适应性**，以应对变化的资源配置和可用性。

---

## 13. 缓存与复制
- **缓存**：减少客户端访问远程服务器的需求，显著提升响应时间。
- **复制**：将资源副本分发到系统的不同节点，减少网络开销并提高效率。

---

## 14. 补充阅读
- **推荐书籍**：《Distributed Systems, Concepts and Design》（4th edition）

---

## 15. 分布式系统 - 分布式并发性
- **集中式系统**：拥有共享内存和时钟，易于确定事件发生时间。
- **分布式系统**：没有统一的时钟，因此难以确定事件发生顺序或同步各组件的操作。

**例子**：
- **多人在线游戏**：如何确定谁先杀死目标并获取积分？
- **make命令**：如何同步分布式系统中的编译步骤？

---

## 16. 物理时钟（Physical Clocks）
- 早期通过地球自转计算一天的时间，随着科技进步，时间的计算精度提高。
- **原子钟**（如铯-133原子）用于精确计时。
- **国际原子时（TAI）**和**协调世界时（UTC）**：UTC基于TAI，并根据地球自转变化加入闰秒调整。

---

## 17. 同步模型的基础
- 每台计算机都有一个定时器，记录自某一时间点以来的“滴答”数。
- 由于硬件误差，各机器的时钟会产生时钟偏差（Clock Skew）。

---

## 18. 实现全局时间（Towards Global Time）
- 时钟同步算法通过定期调整时钟来保持系统的全局时间一致性。

---

## 19. 时钟同步算法（Clock Synchronization Algorithms）
- **集中式算法**：由系统的某个组件提供统一时间（如Cristian's Algorithm）。
- **分散式算法**：多个组件协同提供全局时间（如NTP网络时间协议）。

---

## 20. Cristian's Algorithm
- 客户端定期向时间服务器请求当前时间，服务器返回时间戳，客户端根据延迟调整本地时钟。
- **问题**：单向通信的延迟估计不准确。

---

## 21. Berkeley算法
- 用于局域网的时钟同步，主机定期询问从机的时钟时间，计算平均值并同步所有时钟。
- 如果主机失效，需重新选举新主机。

---

## 22. 平均算法（Averaging Algorithms）
- 每个节点定期广播其当前时间，节点根据接收到的时间样本的平均值调整时钟。
- **问题**：需要丢弃最极端的时间样本以减少故障时钟的影响。

---

## 23. 网络时间协议（NTP）
- NTP是互联网中最广泛使用的时钟同步协议。
- **同步结构**：使用树状的同步子网，根节点从原子钟或卫星接收精确时间，并逐层同步到子节点。

---

# Week - 3

## 2. 逻辑时钟的概念
- **逻辑时钟**是基于事件的相对顺序，而非绝对物理时间。
- **事件排序**：
    1. **时间顺序**：基于事件的发生时间。
    2. **因果排序**：基于因果关系推断事件顺序。

---

## 3. Lamport的逻辑时钟
- **Lamport观察**：进程之间的交互可以被逻辑时钟记录，而不需要同步物理时钟。
- 重要的是事件顺序，而不是实际的物理时间。

---

## 4. “先发生关系” （Happens-Before）
- 如果A在同一进程中发生在B之前，`A → B`。
- 如果A发送消息，B接收消息，则`A → B`。
- **传递性**：如果`A → B`且`B → C`，则`A → C`。

---

## 5. 并发事件
- 如果两个事件a和b没有因果关系，`a || b`，它们是并发的。
- **例子**：分布式系统中，两个进程同时发送消息，但彼此没有依赖关系，表示它们是并发的。

---

## 6. 调整时钟
- 如果一个事件A的时间戳大于应当发生在它之前的事件B，则通过调整接收进程的时钟来纠正。

---

## 7. 多进程消息传递例子
- **P0、P1、P2**三个进程，它们的初始时钟均为0。
- 消息传递顺序按逻辑时钟同步。

---

## 8. 消息传递时序
- **例子**：P0发送消息给P1，P1收到消息后根据时钟调整。时序正确时无需调整。

---

## 9. 时序错误示例
- 如果消息的接收时间戳早于发送时间，则需调整接收方的时钟。

---

## 10. 调整时间戳示例
- 如果时序错误，接收方将其时钟调整为比发送方时间戳大1。

---

## 11. Lamport算法的局限
- Lamport时间戳可以确保`e1 → e2`时，`e1.TS < e2.TS`。
- 但**反之不一定成立**，时间戳不能完全表示事件之间的因果关系。

---

## 12. 向量时钟
- **向量时钟**通过跟踪每个进程的本地时间，可以检测事件的因果关系。
- 向量时钟自增1，并通过消息交换更新。

---

## 13. 向量时钟示例
- 向量时钟可以准确判断两个事件是否有因果关系。
- 如果某进程接收消息时发现时间戳较小，则通过向量时钟调整进程的时钟。

---

## 14. 分布式系统中的全局状态
- 需要捕获系统的**全局状态**用于死锁检测、终止检测或分布式调试。
- **全局状态**由每个进程和通道的局部状态组成。

---

## 15. 切割与一致性切割
- **切割（Cut）**：是进程和通道状态的时间边界。
- **一致性切割**：要求所有依赖关系的事件都包含在同一个切割中。

---

## 16. Chandy-Lamport Snapshot算法
- 用于捕获分布式系统的全局状态，不中断系统运行。
- **步骤**：
    1. 发起快照的进程记录自己的状态，并发送标记消息给其他进程。
    2. 其他进程收到标记消息后，记录局部状态，并记录通道状态。

---

## 17. Chandy-Lamport算法细节
- **标记消息规则**：
    - 进程发送标记消息，指示其他进程开始记录状态。
    - 接收到标记消息的进程，记录通道中消息的状态。

---

## 18. Snapshot算法示例
- **例子**：P1和P2的进程，通过标记消息触发状态记录。所有通道和进程的状态都被记录下来。

---

## 19. 终止条件
- 所有进程和通道的状态都记录完成后，快照过程结束。

---

## 20. 互斥（Mutual Exclusion）
- **互斥**：确保同一时间只有一个进程可以访问共享资源。
- 分布式系统中常用三种互斥算法：
    1. **集中式算法**：一个协调者管理访问。
    2. **分布式算法**：多个进程协作控制互斥。
    3. **令牌环算法（Token Ring）**：进程按顺序传递令牌，持有令牌者进入临界区。

---

## 21. 集中式算法
- **集中式互斥算法**：一个进程（协调者）控制资源访问。简单有效，但存在单点故障风险。

---

## 22. 分布式互斥算法
- **Ricart和Agrawala算法**：进程通过发送请求并等待所有进程的同意来获得资源访问权。

---

## 23. 分布式互斥示例
- 进程P0和P2同时请求资源，P0因时间戳较早获得优先权，之后P2进入临界区。

---

## 24. 令牌环算法（Token Ring）
- **令牌环算法**：进程按顺序传递“令牌”，只有持有令牌的进程可以访问资源。
- **问题**：令牌丢失或进程故障会影响算法运行。

---

## 25. 三种互斥算法的比较
- **集中式算法**：简单但存在单点故障。
- **分布式算法**：无单点故障但复杂。
- **令牌环算法**：保证公平性，但处理故障较复杂。

---

## 26. 选举算法（Election Algorithms）
- **选举算法**：当某个进程崩溃或退休时，选举一个新的进程作为领导者。
- 要求所有进程参与选举，且只选出一个领导者。

---

# 选举算法与分布式文件系统

## 1. 选举算法简介
分布式系统中有时需要某个进程担任“中央服务器”或“协调者”的角色。为了选出领导者，使用了**选举算法**。选举算法的目标是：
- 让所有进程参与并认可领导者的选举过程。
- 保证选举结果的唯一性。
- 领导者持续工作，直到“退役”或出现故障。

在本课程中，主要介绍了两种选举算法：
- **环算法**（Ring Algorithm）
- **霸权算法**（Bully Algorithm）

## 2. 环算法（Ring Algorithm）
环算法由Chang和Roberts在1979年提出，旨在选出ID最大进程作为协调者。其要点如下：
- **逻辑环结构**：进程按逻辑排列成一个环。
- **消息传递方向**：每个进程从左接收消息，向右发送消息。
- **活跃进程列表**：每个进程保存一个活跃进程的ID列表，更新系统中所有进程的状态。

### 2.1 环算法的流程
- **故障检测**：当某个进程发现当前领导者失效，会发起选举消息。
- **消息传递**：消息沿环传递，每个进程根据ID判断是否参与选举。
    - 若接收ID > 自身ID，继续传递；
    - 若接收ID < 自身ID，用自身ID重启选举消息；
    - 若消息回到发起进程，则确定ID最大者为新领导者。

### 2.2 环算法的胜出与确认
- 当选举消息回到发起者时，发起者识别出消息已传递一圈，选择ID最大者为领导者。
- 发起者修改消息为“协调者”消息，通知其他进程新领导者的ID。
- 当该消息传回发起进程时，所有进程确认领导者身份，选举完成。

### 2.3 环算法的性能分析
- **带宽**：最坏情况下，需要传递`3N - 1`条消息。
- **响应时间**：选举结束所需的最小消息数为`3N - 1`。

## 3. 霸权算法（Bully Algorithm）
霸权算法由Garcia-Molina在1982年提出。该算法假设：
- 每个进程知晓其他所有进程的ID和地址。
- 通信可靠，不存在消息丢失的情况。

### 3.1 霸权算法的流程
1. **选举消息**：某进程检测到领导者失效或恢复后，如果ID最高则直接宣布自己为领导者，否则发送选举消息给比自己ID高的进程。
2. **回应消息**：若收到更高ID进程的回应，则停止发送消息，等待胜出通知。
3. **协调者消息**：最终胜出者向所有进程发送协调者消息，通知新的领导者。

### 3.2 霸权算法的选举示例
- **示例1**：当最高ID的领导者失效时，检测到失效的进程向ID更高的进程发送选举消息。
- **示例2**：若某进程响应表示接管选举，则发起进程不再发送消息，等待更高ID进程选出领导者。
- **示例3**：若选举过程中没有高于自身的ID响应，进程可以宣称自己为新的领导者。

### 3.3 霸权算法的性能分析
- **带宽消耗**：最坏情况下带宽消耗为`N² - 1`条消息。
- **响应时间**：最坏情况下为`N-1`条消息。

## 4. 分布式文件系统（DFS）简介
分布式文件系统旨在让远程文件对本地用户可访问，是资源共享的关键技术。常见的文件系统操作包括数据库、分布式共享内存、远程对象等。

### 4.1 文件系统的功能
文件系统负责文件的组织、存储、检索、命名、共享和保护，具体包括：
- **目录模块**：关联文件名和文件ID。
- **文件模块**：关联文件ID和文件内容。
- **访问控制模块**：检查权限。
- **块模块**：管理磁盘块的访问和分配。

## 5. 分布式文件系统的组成部分
- **文件服务器**：硬件（如磁盘）和软件组合，用于处理文件请求。
- **客户端**：发送文件服务请求并提供用户界面。
- **文件服务**：定义文件的基本操作，如创建、删除和读取文件等。

## 6. DFS中的关键问题
DFS中的核心问题包括：
- 命名和透明性
- 远程文件访问
- 缓存一致性
- 文件复制和安全性

## 7. 命名与透明性
- **位置透明性**：文件名不显示存储位置。
- **位置独立性**：文件位置变化时无需更改文件名。

### 7.1 远程资源挂载
当前许多文件系统仍基于单机模式，需要挂载（如NFS）来实现透明访问。挂载远程目录后，可以像本地目录一样访问文件。

## 8. 远程文件访问模式
- **上传/下载模型**：将整个文件下载到客户端，修改后再上传。
- **远程访问模型**：只下载修改的部分，节省存储空间，但会导致更高的网络流量。

### 8.1 缓存与远程访问模型
缓存用于保留最近访问的文件块，减少重复请求，但带来缓存一致性问题。解决方法：
- **客户端发起检查**：由客户端检查数据是否一致。
- **服务器发起检查**：服务器记录每个客户端缓存的文件部分，并在不一致时提醒。

## 9. 缓存策略
- **即时写回（write-through）**：数据立即写入磁盘，可靠性高，性能较低。
- **延迟写回（delayed-write）**：数据写入缓存后批量写回磁盘，性能更好，但数据崩溃时可能丢失。

## 10. 缓存的一致性与效益
- 缓存减少了网络负担，提高了文件系统性能。
- 对于高频写操作系统中，缓存一致性会带来较大开销，因此适合于低频写入的系统。

## 11. 全局命名方案的挑战
- 分布式文件系统需要为每个文件提供统一的命名上下文。
- 全局命名结构，如X.500命名方案或AFS，实现文件名在系统中具有一致的全局视图。
- 这种方案带来了系统集成的复杂性，尤其在处理设备文件和机器特定文件时更为棘手。

## 12. 访问透明性
- 分布式文件系统通过访问透明性让用户无缝操作本地和远程文件。
- 虚拟文件系统（如UNIX的VFS）通过文件ID转换实现透明性，用户使用相同接口访问不同位置的数据。

## 13. 远程文件访问模式
- **上传/下载模式**：将整个文件下载到客户端，修改后再上传。
- **远程访问模式**：仅下载需要的部分数据，避免传输冗余数据。

## 14. 缓存一致性问题
- 缓存一致性问题在于缓存的数据是否与服务器主文件一致。
- 常见解决方法包括：
    - **客户端发起一致性检查**：由客户端验证数据一致性。
    - **服务器发起一致性检查**：服务器记录客户端的缓存数据，在检测到不一致时采取措施。

## 15. 缓存效益
- 缓存减少了网络带宽需求，降低了远程文件访问的开销。
- 适合大容量本地存储的系统，不适合小存储的无磁盘设备。

---

# 分布式文件系统（DFS）

## 2. 大纲
- 分布式文件系统问题：
    - 命名和透明性
    - 远程文件访问
    - 状态服务 vs. 无状态服务
    - 文件复制
    - 安全性
- 示例系统：介绍实际应用中的分布式文件系统案例

---

## 3. 状态文件服务（Stateful File Service）
- **概念**：文件服务器将客户端请求的文件保留在内存中，直到客户端完成操作。
- **工作流程**：
    1. 客户端打开文件。
    2. 服务器从磁盘中获取文件信息，存储在内存中，并向客户端提供唯一的连接标识符。
    3. 客户端使用标识符进行后续访问，直至会话结束。
    4. 服务器必须回收不再活动的客户端的内存空间。
- **优势**：
    - 性能提升，减少磁盘访问。
    - 服务器可以预读取下一个块，提高访问效率。
- **示例**：Andrew File System

## 4. 无状态文件服务（Stateless File Service）
- **概念**：服务器将每个请求视为独立的，无需“打开”或“关闭”文件连接。
- **请求结构**：每个请求需明确指定文件名和数据位置。
- **读写操作**：通过远程消息或缓存查找完成。
- **示例**：网络文件系统（NFS）

---

## 5. 状态 vs. 无状态服务的对比
- **故障恢复**：
    - 状态服务：崩溃时丢失所有临时状态，需要恢复协议或中止操作。
    - 无状态服务：可以无缝恢复，处理自包含请求。
- **客户端故障感知**：状态服务需跟踪客户端故障，回收存储空间；无状态服务不关心客户端状态。
- **无状态服务的代价**：请求信息较长，处理速度较慢。
- **适用场景**：需缓存验证的场合（如Unix文件描述符和偏移量）必须使用状态服务。

---

## 6. 文件复制（File Replication）
- **概念**：为单一逻辑文件创建多个物理副本，提升系统性能和可用性。
- **透明性**：命名服务管理文件副本的引用，用户对副本存在情况透明。
- **实现**：NFS和Windows不支持文件复制，但Andrew File System和CODA系统支持。
- **优势**：
    - 性能提升：通过多个服务器分发请求，或从最近服务器获取文件。
    - 可用性提升：在服务器故障或网络中断时，副本文件仍可访问。

---

## 7. 文件复制问题
- **更新问题**：更新任一副本需同步所有副本，增加带宽开销。
- **需求复制**：当读取非本地副本时，在本地缓存生成副本，带来副本管理开销。
- **并发问题**：多个用户同时更新副本时需解决冲突，确定最终保存内容。

---

## 8. 命名与透明性
- **命名**：文件名是文件的文本标签，映射到物理存储位置。通常采用分层结构，如`/etc/passwd`。
- **位置透明性**：文件名不暴露存储位置，便于共享。
- **位置独立性**：文件位置改变时无需更改文件名。

---

## 9. 访问透明性
- **功能**：通过访问透明性提供一致的本地和远程文件管理操作。
- **实现**：例如UNIX的虚拟文件系统（VFS），通过文件ID转换实现透明性，用户可以通过相同的接口访问本地或远程文件。

---

## 10. 全局命名方案
- **概念**：在DFS中，确保每个文件在系统内具有一致的全局视图。
- **实现案例**：X.500命名方案和AFS使用单一的全局名称结构，确保一致性，但集成复杂性较高。

---

## 11. 远程文件访问模式
- **上传/下载模型**：将整个文件下载至客户端，修改后上传，适合简单文件操作。
- **远程访问模型**：仅下载需要的部分数据，减少存储空间需求，但带来频繁的网络请求。

---

## 12. 缓存一致性问题
- **问题**：缓存引发的一致性问题，需确保本地缓存的数据与服务器主文件一致。
- **客户端检查**：客户端发起一致性检查，服务器验证数据一致性。
- **服务器检查**：服务器记录每个客户端缓存的文件部分，检测到不一致时采取措施。

---

## 13. 缓存的优势
- **网络流量减少**：缓存减少网络流量，使远程访问接近本地速度，适合低频写入的模式。
- **高频写入的挑战**：在高频写入的情况下，一致性维护开销较大，但对多数远程操作，缓存显著提高了访问效率。

---

## 14. Flat File System（FFS）
- **概述**：无状态文件系统的抽象架构，类似于Network File System（NFS）和Andrew File System（AFS）。
- **组成部分**：
    - **Flat File Service**：负责文件内容操作。
    - **Directory Service**：管理文件名称和文件标识符（UFID）的映射。
    - **Client Module**：提供标准化接口，适配不同操作系统。
- **文件命名约束**：Flat File System要求文件名唯一，不允许重复。

---

## 15. 文件服务器架构
- Flat File System由三大组件组成：
    - Flat File Service：提供文件操作接口。
    - Directory Service：提供文件名到文件ID的映射服务。
    - Client Module：为用户提供统一的API支持。

---

## 16. Flat File Service
- **功能**：负责文件内容的增删改查操作。
- **UFID（唯一文件标识符）**：每个文件有唯一的UFID，确保分布式文件系统中的唯一性。
- **文件创建流程**：生成新的UFID并返回给请求者。

---

## 17. Directory Service
- **功能**：文件文本名称与UFID的映射服务。
- **支持操作**：
    - 生成新目录
    - 将文件名添加至目录
    - 从目录中删除UFID

---

## 18. Client Module
- **单一实例**：每台计算机一个实例，集成Flat File Service和Directory Service的操作。
- **缓存支持**：缓存文件块并采用写时更新策略。
- **UNIX平台适配**：模拟完整的UNIX文件操作，包括多级文件名的解释。

---

## 19. Sun NFS
- **概述**：由Sun Microsystems开发，支持网络工作站间文件共享。
- **协议**：
    - Mount Protocol：用于连接和挂载文件系统。
    - NFS Protocol：实现文件系统的无状态操作。

---

## 20. NFS架构
- **架构组件**：
    - 客户端计算机：负责将文件操作请求发送到服务器。
    - 服务器计算机：处理客户端请求。
    - 虚拟文件系统（VFS）：管理本地和远程文件系统的操作。

---

## 21. 虚拟文件系统（VFS）
- **功能**：支持访问透明性，将文件系统通用操作与具体实现分离。
- **vnode结构**：用于文件实现，指示文件是本地还是远程，分别使用inode标识或NFS文件句柄。

---

## 22. NFS文件句柄
- **文件句柄结构**：由文件系统标识符、inode编号、inode生成号组成，确保唯一性。
- **VFS管理**：在VFS层管理，以确保分布式系统中文件的唯一性。

---

## 23. 挂载协议
- **流程**：客户端使用UNIX命令`mount`向NFS服务器发起挂载请求。
- **验证**：NFS客户端通过VFS发送请求，服务器验证并返回文件句柄。
- **共享配置**：服务器在`/etc/exports`文件中列出共享文件，并通过访问控制列表管理权限。

---

## 24. 客户端缓存
- **一致性检查**：客户端负责检查缓存数据是否有效，每次文件操作前都需确认数据一致性。
- **时间戳验证**：缓存数据有效期根据文件使用情况自适应设置，以提升性能。

---

## 25. 安全性
- **无状态安全机制**：每个RPC请求包含认证信息，确保安全。
- **扩展支持**：Sun RPC


# 分布式文件系统 - 第二部分 (AFS 与 P2P)

## 1. AFS 简介
- **开发背景**：由卡内基梅隆大学与IBM合作开发。
- **主要目标**：支持高达5000个并发用户的文件共享，确保系统的可扩展性和安全性。
- **两大设计特点**：
    - **整文件服务**：整个文件或目录会被传输到客户端。
    - **整文件缓存**：一旦文件被传输，便永久存储在本地缓存中。

## 2. AFS 的典型文件访问流程
- 客户端检查缓存，如果文件不在缓存中则从服务器下载文件到缓存。
- 客户端关闭文件时，如果文件有更改，则会将更改上传回服务器。

## 3. 上传/下载模式的原因
- 文件通常很小（小于10KB），读操作远多于写操作。
- 顺序访问较为常见，大多数文件仅被一个用户访问和修改。
- 设计基于学术环境中的典型工作负载，以减少网络传输和服务器压力。

## 4. AFS 设计问题
- 使用大缓存（如100MB）存储经常访问的文件，减少对服务器的依赖。
- 对于频繁被多用户访问和更新的文件（如数据库），缓存机制的效率不高。

## 5. AFS 系统架构
- **Vice**：运行在服务器端，实现扁平文件服务，负责文件分组与唯一标识。
- **Venus**：运行在客户端，负责更新本地缓存，管理共享目录结构。
- **文件标识符（fid）**：每个文件都有唯一的96位fid，便于定位和管理。

## 6. 缓存一致性
- **回调承诺（Callback Promise）**：Vice为传输给客户端的文件提供承诺，其他客户端修改文件时通知相关客户端。
- 客户端重启时需对缓存中的文件进行验证，确保文件最新有效。

## 7. AFS 更新语义
- 尽量接近UNIX的单一副本语义（One-Copy Semantics），确保写操作会更新所有缓存副本，以保持一致性。
- 采用“**写入时更新（Write-on-Close）**”策略来同步缓存和服务器数据。

## 8. 其他特点
- **多线程**：Venus和Vice均为多线程，能够同时处理多个请求。
- **只读副本**：经常被读取的文件（如/bin）有多个只读副本以提高访问效率。
- **批量传输**：64k的传输限制减少了网络开销。

## 9. P2P 系统简介
- **去中心化设计**：节点共享资源并共同承担系统责任，没有集中控制。
- **每个节点既是客户端又是服务器**，适用于大规模不可变数据的共享。

## 10. P2P 系统的类型
- **集中式系统**：通过服务器协调通信（如SETI@home）。
- **去中心化系统**：节点独立运行，无集中服务（如Gnutella）。
- **混合系统**：通过服务器发现节点，但节点间通信独立（如Napster）。

## 11. P2P 中间件系统与路由覆盖
- **P2P中间件系统**：基于第二代架构，部分节点用作基础设施节点，以提高性能。
- **路由覆盖（Routing Overlay）**：用于在应用层路由请求，帮助查找和访问目标资源。
- **全局唯一标识符（GUID）**：用于标识和检索资源，支持位置无关的存储和查找。

## 12. 分布式哈希表（DHT）
- **DHT 的基本操作**：
    - **put(GUID, data)**：在多个节点上存储数据副本。
    - **get(GUID)**：从存储该数据的节点检索数据。
    - **remove(GUID)**：删除与该GUID相关的所有数据。
- **DHT 特性**：
    - **去中心化**：节点共同维护映射关系。
    - **可扩展性**：系统在数百万节点情况下仍能高效运行。
    - **容错性**：通过对象复制确保系统在节点加入、离开和失效时的可靠性。


# 点对点网络（P2P Networks） - 总结笔记

## 1. 路由覆盖 vs IP 路由

### 1.1 可扩展性
- **IP 路由**:
    - IPv4 地址空间限制为 2^32 个节点，实际上由于层次结构，许多地址不可用，IPv6 可以解决部分扩展问题，但仍有层次结构限制。
- **路由覆盖**:
    - P2P 系统通过 GUID 处理更多对象。
    - GUID 名称空间非常大（> 2^128），采用平坦结构，所有地址都可以使用。

### 1.2 负载均衡与网络动态性
- **负载均衡**：
    - IP 路由的负载由网络拓扑和流量模式决定。
    - 路由覆盖中对象的位置可以随机化，流量模式不受网络拓扑限制。
- **网络动态性**：
    - IP 路由表的更新是异步的，通常在一小时左右。
    - 路由覆盖中，路由表的更新可以是同步或异步的，延迟通常在几秒内。

### 1.3 故障容错与目标识别
- **故障容错**：
    - IP 路由通过冗余设计实现容错，但代价昂贵。
    - 路由覆盖通过多副本机制，确保对节点或连接失效的容忍能力。
- **目标识别**：
    - IP 地址对应唯一的目标节点。
    - 路由覆盖可以将消息发送到目标节点的最近副本。

### 1.4 安全性与匿名性
- **IP 路由**：当所有节点是可信的时，安全性有保障，但无法提供匿名性。
- **路由覆盖**：即使在有限信任环境中也能实现安全性，提供一定程度的匿名性。

## 2. P2P 系统总结
- P2P 中间件平台可以将请求递交到互联网上的任何数据对象，无论它们在哪里。
- 使用 GUID 作为对象地址，实现对象的匿名性。
- 对象通过特定的映射基础设施（如 DHT 模型）管理。
- 使用安全哈希函数（如 SHA-1）生成 GUID，增加完整性保证。
- 基于对象复制和容错路由算法，提供可用性保证。
- P2P 系统能够利用主机中的未使用资源（存储、处理），支持大规模扩展，且自组织性使得支持成本与节点数量无关。

## 3. 案例研究 1: Pastry
- **Pastry GUID 分配**:
    - 节点和对象通过 128 位 GUID 进行标识，使用安全哈希函数计算。
    - 路由算法在包含 N 个节点的网络中，以 O(log N) 步路由消息到目标节点。
- **Pastry 路由覆盖**:
    - 消息通过底层协议（如 UDP）传输到更接近目标的节点。
    - 使用局部性度量优化路由表，确保消息传递路径的高效。
    - 当新节点加入或节点离开时，Pastry 网络能自动调整状态，确保一致性。
- **路由机制**:
    - Pastry 使用前缀路由，根据 GUID 确定传递路径。
    - 每个节点维护一个叶子集合（Leaf Set），包含数值上最接近的节点。
    - 路由表和叶子集合确保消息能快速传递到目标。
- **节点加入与离开**:
    - **加入**：新节点通过现有节点的信息初始化路由表、叶子集合和邻居集合。
    - **离开**：系统通过邻居节点协作修复路由表和叶子集合，确保网络稳定性。

## 4. 案例研究 2: BitTorrent

### 4.1 BitTorrent 的基本原理
- **BitTorrent**是用于大文件分发的 P2P 文件共享协议。
    - 将文件切分为多个片段，每个节点（下载者）获取不同片段后继续共享，最终完成整个文件的组装。
    - **Swarm（群）**：所有下载相同文件的节点的集合。
- **.torrent 文件**：
    - 包含文件元数据和跟踪服务器信息。
    - 节点通过 `.torrent` 文件连接到跟踪服务器，获取关于其他节点的下载信息。

### 4.2 组件与工作原理
- **种子节点（Seed）**：拥有完整文件的节点。
- **下载节点（Leech）**：拥有部分文件片段的节点。
- **跟踪服务器（Tracker）**：
    - 负责维护所有节点列表，协调文件片段的分发。
    - 通过 HTTP/HTTPS 与客户端通信，返回包含节点信息的响应。
- **Seeder 与 Initial Seeder**：
    - Seeder 是提供完整文件的节点，Initial Seeder 是最初提供文件副本的节点。

### 4.3 BitTorrent 目标与策略
- **效率**：通过从多个节点下载实现快速传输。
    - 下载片段时优先选择稀有片段，确保网络中的片段分布均匀，减少片段重叠。
- **可靠性**：通过片段的多副本确保节点离线的情况下文件仍然可用。
    - 增加稀有片段的分布数量，确保系统在节点动态变化时的稳定性。

### 4.4 BitTorrent 总结
- BitTorrent 通过使用跟踪服务器维护与共享文件相关的种子和下载者列表。
- 与 Napster 不同，BitTorrent 服务器不存储文件名称信息，仅使用 `info_hash` 识别文件。
- BitTorrent 通过片段下载提高下载速度和匿名性，同时提升了文件的可用性。

## 5. 结束语
- 本次内容涵盖了 P2P 网络中 Pastry 与 BitTorrent 系统的工作原理和关键技术。
- 如果对内容有进一步的疑问，可以联系讲座的作者 Dr. Aidan Murphy 进行了解。


# 分布式系统 - 组通信总结笔记

## 1. 组通信概述
- **多播通信（Multicast Communication）**：
    - 一种将单一消息几乎同时发送给一组进程的机制。
    - 组通信实现需考虑：
        - 静态 vs 动态组
        - 多播 vs 单播
- **组通信的优点**：
    - **效率**：通过多播，可以将一条消息发送给n个进程，而不是分别发送n条消息，从而节省带宽。
    - **交付保证**：相较于基于单播的方式，使用多播可以减少部分进程无法收到消息以及消息顺序不确定的问题。

## 2. 多播通信类型
- **不可靠多播（Unreliable Multicast）**：
    - 无法保证消息的传递或顺序，消息仅被发送一次。
- **可靠多播（Reliable Multicast）**：
    - 尽最大努力确保所有组成员都能接收到消息。
- **原子多播（Atomic Multicast）**：
    - 要么被接收组的所有进程接收，要么都不接收。

## 3. IP 多播
- **IP 多播**是IP协议的一种扩展，支持向进程组发送消息，使用 224.x.x.x 到 239.x.x.x 范围的 IP 地址。
- 支持动态组成员的加入和退出。
- 使用 UDP 协议传输消息，但不保证消息的交付。
- **Mbone（Multicast Backbone）**：
    - 一种松散的多播路由器联盟，支持 IP 多播包在互联网上路由。
- 可以使用**TTL（Time To Live）**值来限制多播的传播距离。

## 4. 多播系统模型
- 假设一组可以通过**一对一信道**可靠地通信的进程。
- 这些进程被组织成组，每个组都有**全局唯一标识符**，并且进程可以加入多个组。
- **操作定义**：
    - **multicast(g, m)**：将消息m发送给组g的所有成员。
    - **deliver(m)**：消息m被多播发送后交付给接收的进程。
    - **sender(m)**：返回消息m的发送者。
    - **group(m)**：返回消息m的目标组的唯一标识符。

## 5. 基本多播（Basic Multicast）
- 一种原始的多播协议，保证消息发送到静态组中的所有进程。
- **B-multicast(g, m)** 发送消息 m 到组 g，**B-deliver(m)** 将消息交付给调用进程。
- **实现方法**：基于一个可以保证消息交付的单播协议，例如TCP。
    - 使用 **send(p, m)** 发送消息到进程p。
    - 进程 p 接收消息时，调用 **receive(m)**。
- 多播的实现方式是在调用 **B-multicast(g, m)** 时，为每个组成员分别调用 **send(p, m)**。

## 6. 基本多播中的多线程与ACK爆炸
- **ACK 爆炸**：每次收到消息时，进程需要向发送方发送确认（ACK），随着组规模的增加，ACK的数量也会增加。
    - 如果这些ACK同时返回，发送者的缓冲区可能会被填满，导致部分ACK被丢弃，从而需要重传消息。
- 为了解决这些问题，可以使用更高效的实现方式，如**IP多播**。

## 7. 可靠多播（Reliable Multicast）
- **可靠多播**是对基本多播的扩展，其主要特性包括：
    1. **传递保证（Guaranteed Delivery）**：基于基本多播。
    2. **完整性（Integrity）**：正确的进程最多只能交付一次消息。
    3. **有效性（Validity）**：如果正确的进程多播消息，那么它将最终交付该消息。
    4. **一致性（Agreement）**：如果一个正确的进程交付消息，所有其他正确的进程也将最终交付。
- **实现方式**：
    - 使用 **IP 多播**：假设IP多播通常是成功的。
    - **附带ACK（Piggy-backed ACKs）**：ACK作为多播消息的一部分进行传输。
    - **负确认（NAKs）**：当某个进程检测到自己错过了消息时，发送NAK。

## 8. 组成员服务（Group Membership Service, GMS）
- **组成员服务（GMS）**提供对组成员的动态管理以及多播通信的支持，其主要目标包括：
    1. 提供组成员变更的接口，例如创建或销毁组、增加或移除成员。
    2. **故障检测**：监控组成员的崩溃和故障，标记成员为“可疑”或“不可疑”。
    3. 通知组内成员有关组成员变更的情况。
    4. 执行**组地址扩展**，将消息关联到组成员地址，保证多播消息被正确传递。

## 9. 组视图（Group Views）
- **组视图**：一个有序的列表，包含当前组的所有成员，并根据进程加入的顺序排列。每个成员都由其唯一的进程标识符表示。
- 视图是由GMS生成并传递给所有组成员的，当组内有成员加入、离开或出现故障时，GMS会更新视图。
- **视图交付**：当组成员变化时，GMS会将新的组视图传递给所有当前成员。

## 10. 视图交付的实现要求
- 视图交付实现需要满足以下要求：
    1. **顺序性（Order）**：如果进程 p 先后交付了视图 v 和 v'，则没有其他进程能在 p 之前交付 v'。
    2. **完整性（Integrity）**：如果进程 p 交付了视图 v，则 p 必须是 v 中的成员。
    3. **非平凡性（Non-triviality）**：如果进程 q 加入了组，且可以从进程 p 到达，那么最终 q 将出现在 p 的视图中。

## 11. 视图同步组通信（View-Synchronous Group Communication）
- **视图同步组通信**通过使用组视图来约束消息的交付。
    - 通过新的视图交付，系统确定消息的交付是否应该发生。
    - 只有在接收到新的视图之前，进程才能交付消息，确保消息与视图同步。
- **额外保证**：
    - **一致性（Agreement）**：所有正确进程交付相同的视图顺序和消息顺序。
    - **完整性（Integrity）**：如果一个正确进程交付了消息 m，那么它不会再次交付该消息，而且该进程属于消息 m 的目标组。
    - **有效性（Validity）**：正确的进程总是交付它们发送的消息。如果系统未能交付消息给某个进程，会通过交付新视图的方式通知其他进程。

## 12. 总结
- **组/多播通信**：致力于将消息高效地发送给一组进程，支持静态和动态组。
- **基本多播**：保证消息交付，但可能面临 ACK 爆炸问题。
- **可靠多播**：通过消息的完整性、一致性和有效性保证，提高消息传递的可靠性。
- **组成员服务**：为组成员变更提供管理、故障检测和通知等功能。
- **视图同步组通信**：通过视图同步机制，确保消息交付的可靠性和一致性。


# 分布式系统：复制系统

## 1. 一致性
- **定义**：复制系统中副本数据的一致性是衡量其正确性的关键指标。
- **严格一致性（Linearizability）**：
    - 任何读操作返回最近一次写操作的结果。
    - 要求全局时间顺序，所有操作表现为在单线程中执行。
- **顺序一致性（Sequential Consistency）**：
    - 满足每个客户端的本地顺序，而不需要全局时间顺序。
    - 更适合对性能要求高的场景。

---

## 2. 被动复制（Passive Replication）
- **架构**：
    - 主副本处理所有请求并将更新传播给备份副本。
    - 备份副本作为主副本的候选者，在主副本失效时接替。
- **流程**：
    1. 前端发送请求至主副本。
    2. 主副本按顺序处理请求。
    3. 更新操作同步至备份副本，备份发送确认消息。
    4. 主副本向前端返回结果。
- **特点**：
    - 提供 **线性化一致性**。
    - 单点故障风险高，性能受主副本瓶颈限制。
- **容错性**：
    - 容忍 `f` 个故障需要至少 `f+1` 个副本。

---

## 3. 主动复制（Active Replication）
- **架构**：
    - 所有副本管理器（RMs）具有对等地位，通过多播同时接收请求。
- **流程**：
    1. 前端通过全序多播发送请求。
    2. 所有副本以相同顺序独立处理请求。
    3. 副本返回结果给前端，前端综合结果后向客户端反馈。
- **特点**：
    - 提供 **顺序一致性**。
    - 无单点故障，高可靠性，但多播通信成本高。

---

## 4. Gossip 架构
- **定义**：
    - 一种分布式系统框架，用于实现高可用性和最终一致性。
    - 副本之间通过定期的 Gossip 消息交换数据更新。
- **两类操作**：
    1. **查询（Query）**：只读操作，返回副本的当前状态。
    2. **更新（Update）**：修改操作，通过 Gossip 消息传播至其他副本。
- **保证**：
    1. 客户端一致性：返回的数据至少包含客户端已观测到的所有更新。
    2. 副本一致性：所有副本最终接收到相同的更新。
- **消息机制**：
    - Gossip 消息包含日志和时间戳，用于同步更新。
    - 副本接收消息后合并日志，应用稳定更新，并清理已处理的记录。

---

## 5. Medianode 案例研究
- **背景**：
    - 一个多媒体教学资料共享的开放基础设施。
    - 支持高可用性、一致性、地理分布和透明访问。
- **数据类型**：
    1. **演示内容**：核心教学资料。
    2. **描述数据**：XML 格式的元数据。
    3. **系统元数据**：用户、会话信息等。
- **副本分类**：
    1. **元副本（Metareplica）**：存储元数据。
    2. **软副本（Softreplica）**：非持久性小型数据。
    3. **真副本（Truereplica）**：大型持久性数据，如多媒体文件。
- **更新机制**：
    - 副本管理器维护本地文件表，记录副本信息。
    - 更新通过多播传播至相关副本子组。

---

## 6. 总结
- **一致性模型**：
    1. 被动复制：线性化一致性，主从架构。
    2. 主动复制：顺序一致性，全局多播。
- **Gossip 架构**：
    - 通过定期的消息交换实现最终一致性。
- **Medianode 的价值**：
    - 在高故障和网络分区环境下提供高可用性和一致性。


# 分布式系统：安全性 (Distributed Systems: Security)

---

## 1. 分布式系统中的安全性 (Security in Distributed Systems)

### 1.1 为什么分布式系统易受攻击？
- **原因**：
  1. **资源共享**（Resource Sharing）：系统开放，允许外部访问。
  2. **服务接口暴露**（Exposed Interfaces）：对外提供的服务接口可能成为攻击入口。
  3. **不安全的网络**（Insecure Networks）：数据传输过程中可能被窃听或篡改。
  4. **算法暴露**（Algorithm Exposure）：攻击者可能了解系统的实现方式和算法。

---

## 2. 保护资源 (Protecting Resources)
- 保护目标：
  1. 执行共享对象的进程（Processes Executing Shared Objects）。
  2. 与共享对象通信的资源（Resources Communicating with Shared Processes）。

---

## 3. 安全政策 vs 安全机制 (Security Policy vs Mechanisms)
- **安全机制**（Security Mechanisms）：
  - 提供保护资源的技术手段，例如锁（Lock）。
- **安全政策**（Security Policies）：
  - 管理机制使用的规则，例如“无人看守时必须锁门”。
- **关键点**：
  - 机制与政策缺一不可，仅提供机制或仅设定规则无法保障安全。

---

## 4. 三大安全威胁 (Three Security Threats)
1. **信息泄露**（Leakage）：未授权用户获取信息。
  - 案例：Choicepoint 泄露 163,000 条数据记录。
2. **信息篡改**（Tampering）：未授权修改信息。
  - 案例：E-Trade 因黑客攻击损失 $18M。
3. **恶意破坏**（Vandalism）：攻击者干扰系统正常运行。
  - 案例：网站被涂鸦。

---

## 5. 五种攻击方法 (Five Methods of Attack)
1. **窃听**（Eavesdropping）：未授权拷贝通信内容。
  - 案例：使用 Trojan 病毒监听手机短信和通话。
2. **伪装**（Masquerading）：冒充合法用户发送或接收消息。
  - 案例：伪造银行邮件引导用户访问假登录页面。
3. **消息篡改**（Message Tampering）：拦截并修改消息内容。
  - 案例：中间人攻击（Man-in-the-Middle Attack）。
4. **重放攻击**（Replaying）：存储消息后在稍后重新发送。
  - 案例：重用已拦截的银行 HTTP 请求登录。
5. **拒绝服务攻击**（Denial of Service, DoS）：通过洪水式消息阻止其他用户访问资源。
  - 案例：2000 年 Yahoo 和 Amazon 遭受 DoS 攻击。

---

## 6. 安全系统设计原则 (Designing Secure Systems)
- **最坏情况假设**（Worst-Case Assumptions）：
  1. 接口暴露。
  2. 网络不安全。
  3. 算法可能公开。
  4. 攻击者拥有丰富资源。
- **设计指导**：
  1. 限制密码和密钥的生命周期（Limit Lifetime of Secrets）。
  2. 最小化可信基（Minimize the Trusted Base）。

---

## 7. 密码学简介 (Introduction to Cryptography)
- **密码学**（Cryptography）：通过编码保护信息安全。
- **密码分析**（Cryptanalysis）：破解加密的过程。
- **密码学领域**（Cryptology）：密码学与密码分析的结合。

---

## 8. 加密系统的基本概念 (Cryptosystem)
- 加密过程：
  - 明文（Plaintext, p）→ 加密（Encryption, e）→ 密文（Ciphertext, c）。
  - 解密过程：`dK(eK(p)) = p`。
- **Kerckhoffs 原则**（Kerckhoffs' Principle）：
  - 密码系统的安全性应基于密钥的保密，而非算法的隐藏。

---

## 9. 加密的类型 (Types of Cryptography)
1. **对称加密**（Symmetric Key Cryptography）：
  - 使用相同的密钥进行加密和解密。
  - 类型：
    1. **流加密**（Stream Cipher）：生成长密钥流加密数据。
    2. **分组加密**（Block Cipher）：对固定大小的数据块加密。
2. **公钥加密**（Public Key Cryptography）：
  - 使用一对密钥：公钥加密，私钥解密。
  - 适合数字签名和安全通信。
3. **哈希算法**（Hash Algorithm）：
  - 单向加密，验证数据完整性。

---

## 10. 公钥加密 (Public Key Cryptography)
- **机制**：
  - 公钥（Public Key, pk）：加密或验证签名。
  - 私钥（Private Key, sk）：解密或生成签名。
- **应用**：
  1. **数字签名**（Digital Signatures）：私钥生成签名，公钥验证。
  2. **保密通信**（Confidential Communication）：公钥加密消息，私钥解密。

---

## 11. 加密的实际应用 (Uses of Cryptography)
1. **机密性**（Secrecy）：确保数据只有授权用户能访问。
2. **完整性**（Integrity）：保证数据未被篡改。
3. **身份认证**（Authentication）：验证通信双方的身份。
4. **数字签名**（Digital Signatures）：提供消息来源验证和不可抵赖性。

---

## 12. 总结 (Summary)
- 分布式系统的安全性依赖以下技术：
  1. 对称加密：高效但需解决密钥分发问题。
  2. 公钥加密：解决密钥分发问题，但计算复杂度高。
  3. 数字签名和认证机制：确保通信安全和可信性。
- 安全设计需综合利用多种技术，应对不同安全威胁。

---


# 分布式系统安全性：第二部分 (Distributed Systems: Security - Part 2)

---

## 1. 密码学的应用 (Applications of Cryptography)
- **主要应用**：
  1. **数字证书（Digital Certificates）**：验证用户身份的工具。
  2. **访问控制（Access Control）**：控制用户对资源的访问权限。
  3. **能力清单（Capabilities）**：简化权限分配和管理的工具。

---

## 2. 数字证书 (Digital Certificates)
- **定义**：
  - 数字证书是电子消息的附件，用于验证用户是否是其声称的身份。
- **关键问题**：
  1. 证书应该包含哪些信息？
  2. 如何创建证书？
  3. 如何验证证书？
  4. 证书吊销时如何处理？
- **信任链（Certification Chain）**：
  - 证书由可信任机构（Trusted Authority）签发，高级别机构可以授权下级机构签发证书。
- **常用标准**：
  - X.509 是最广泛使用的数字证书标准。

---

## 3. 认证 vs 授权 (Authentication vs Authorization)
- **认证（Authentication）**：
  - 验证用户的身份，回答“你是谁？”。
- **授权（Authorization）**：
  - 验证用户的操作权限，回答“你能做什么？”。
- **关系**：
  - 授权是认证后的操作，是访问控制的关键组成部分。

---

## 4. 系统认证 (System Certification)
- **背景**：
  - 政府对产品安全等级进行认证的尝试，例如“橙皮书”（Orange Book）。
- **橙皮书（Orange Book）**：
  - 全名：可信计算系统评估标准（Trusted Computing System Evaluation Criteria, TCSEC）。
  - 目标：
    1. 提供评估安全产品的标准。
    2. 提供构建安全产品的指导。
  - 等级分类：
    - D（最低等级）到 A（最高等级）。

---

## 5. EAL 安全等级 (Evaluation Assurance Level)
- **从 1 到 7 的安全等级**：
  1. **EAL1**：功能测试（Functionally Tested）。
  2. **EAL2**：结构性测试（Structurally Tested）。
  3. **EAL3**：方法性测试和检查（Methodically Tested and Checked）。
  4. **EAL4**：设计、测试和审查（Designed, Tested, and Reviewed）。
  5. **EAL5**：半形式化设计和测试（Semiformally Designed and Tested）。
  6. **EAL6**：验证设计和测试（Verified, Designed, and Tested）。
  7. **EAL7**：形式化验证（Formally Verified）。

---

## 6. 访问控制 (Access Control)
- **访问控制矩阵（Access Control Matrix）**：
  - 存储用户和资源的权限信息。
- **优化方式**：
  1. **访问控制列表（Access Control List, ACL）**：
    - 按资源存储权限。
    - 数据导向，适合用户自行管理资源权限。
  2. **能力清单（Capabilities, C-Lists）**：
    - 按用户存储权限。
    - 用户导向，易于权限委托和动态管理。

---

## 7. 多级安全性模型 (Multilevel Security, MLS)
- **定义**：
  - 在不同安全级别的用户和资源共享系统时，需要多级安全性。
- **应用**：
  1. 政府和军队的机密信息系统。
  2. 企业内部的管理权限控制。
  3. 网络防火墙和医疗数据库的保护。

---

## 8. Bell-LaPadula 模型 (BLP Model)
- **目标**：保护数据的机密性（Confidentiality）。
- **核心原则**：
  1. **无读上原则（No Read Up, Simple Security Rule）**：
    - 用户不能读取高于自身权限的信息。
  2. **无写下原则（No Write Down, *-Property）**：
    - 用户不能将信息写入低于自身权限的资源。

---

## 9. Biba 模型 (Biba Model)
- **目标**：保护数据的完整性（Integrity）。
- **核心原则**：
  1. **无写上原则（No Write Up）**：
    - 用户不能写入高于自身权限的信息。
  2. **无读下原则（No Read Down）**：
    - 用户不能读取低于自身权限的信息。

---

## 10. Kerberos 认证协议 (Kerberos Authentication Protocol)
- **定义**：
  - 一种网络认证协议，允许节点在不安全的网络中安全验证身份。
- **核心特点**：
  1. **强第三方认证（Strong Third-Party Authentication）**：
    - 通过可信的密钥分发中心（Key Distribution Centre, KDC）完成认证。
  2. **单点登录（Single Sign-On, SSO）**：
    - 用户只需一次登录即可访问多个服务。
  3. **无明文密码传输（No Password Transmission in Clear Text）**：
    - 增强了网络通信的安全性。
- **工作原理**：
  1. 用户和服务与 KDC 共享密钥。
  2. KDC 生成会话密钥并安全分发给双方。
  3. 用户和服务通过会话密钥验证身份。

---

## 11. Kerberos 系统架构 (Kerberos System Architecture)
- **组件**：
  1. **客户端（Client）**：发起认证请求。
  2. **服务端（Server）**：提供目标服务。
  3. **密钥分发中心（Key Distribution Centre, KDC）**：
    - 管理用户和服务的认证。
- **认证流程**：
  1. 客户端请求 KDC 生成会话密钥。
  2. KDC 分发会话密钥给客户端和服务端。
  3. 客户端和服务端通过会话密钥验证彼此身份。

---

## 12. 总结 (Summary)
- **分布式系统安全性关键点**：
  1. **密码学的应用**：
    - 数字证书、访问控制和能力清单。
  2. **安全模型**：
    - Bell-LaPadula 模型保护机密性。
    - Biba 模型保护完整性。
  3. **认证协议**：
    - Kerberos 提供高效、安全的认证机制。

---

# 网格计算入门 (Introduction to Grid Computing)

---

## 1. 什么是网格计算？(What is the Grid?)
- **定义**：
  - 网格计算类似于电网的概念，用户像使用电力一样使用计算资源。
  - 支持异构资源（不同硬件、操作系统、编程语言和应用）的共享。
- **特点**：
  1. 分布式系统，松散耦合（Loosely Coupled）。
  2. 地理上分散（Geographically Dispersed）。
  3. 强调资源管理与安全性。
- **关键目标**：
  - 通过中间件（Middleware）实现文件、计算机、软件、数据和传感器的共享。

---

## 2. 案例：全球望远镜项目 (World Wide Telescope)
- **背景**：
  - Microsoft Research 开发的天文数据共享项目。
- **功能**：
  1. 统一全球的天文学档案，构建大型数据库。
  2. 提供文献、图像、原始数据和衍生数据。
  3. 数据存储量巨大，分析过程计算需求高。
- **核心技术**：
  - 通过标准化元数据（Metadata）描述数据和设备特性，如时间、地点和仪器。

---

## 3. 网格计算的需求 (Requirements of a Grid)
1. **远程资源访问**（Remote Access to Resources）。
2. **本地数据处理**（Processing Where Data Is Stored）。
3. **动态服务创建**（Dynamic Service Creation）。
4. **元数据支持**：
  - 描述数据特性（区域、时间、仪器）。
  - 描述服务特性（成本、位置、负载、可用空间）。
5. **目录服务**（Directory Services）：
  - 基于元数据查找适合的服务。
6. **管理软件**（Management Software）：
  - 管理查询、数据传输和资源分配。

---

## 4. 开放网格服务架构 (Open Grid Services Architecture, OGSA)
- **定义**：
  - 网格计算的标准框架，基于 Web 服务。
- **特点**：
  1. 提供标准化接口。
  2. 支持应用级别的网格服务。
  3. 通过中间件整合资源管理、安全和服务调度。
- **层次结构**：
  1. OGSA 层：目录服务、管理服务、安全服务。
  2. OGSI 层：命名方案、标准数据元素、故障模型。

---

## 5. 开放网格服务基础设施 (Open Grid Services Infrastructure, OGSI)
- **功能**：
  1. 定义动态服务实例的命名方案：
    - **网格服务句柄（Grid Service Handle, GSH）**：唯一标识符。
    - **网格服务引用（Grid Service Reference, GSR）**：实例位置和访问方式。
  2. 支持服务数据（Service Data）的访问和操作。
  3. 提供统一的故障模型和通知服务。
- **故障模型**：
  - 使用 XML 描述，包括时间戳、故障来源、错误码等。

---

## 6. OGSA 服务 (OGSA Services)
- **高级服务**：
  - 目录服务：支持基于元数据的服务选择。
  - 管理服务：监控资源、处理任务分配和 SLA（服务级别协议）。
  - 安全服务：提供单点登录、委托认证和加密支持。
- **应用**：
  - 数据密集型任务（如全球望远镜）。
  - 计算密集型任务（如图像处理和科学模拟）。

---

## 7. Globus 工具包 (Globus Toolkit)
- **背景**：
  - 1994 年启动的 Globus 项目，旨在为科学计算应用提供标准化的软件。
  - Globus Toolkit 是网格计算的事实标准。
- **功能模块**：
  1. **执行管理（Execution Management）**。
  2. **数据管理（Data Management）**。
  3. **安全模块（Security）**。
  4. **公共运行时环境（Common Runtime Environment）**。
- **最新版本**：
  - 截至 2014 年的第 6 版（v6.0）。

---

## 8. 总结 (Summary)
- **网格计算的核心技术**：
  1. OGSA：统一的架构和标准化接口。
  2. Globus Toolkit：支持执行管理、数据管理和安全功能。
- **典型应用**：
  1. 数据密集型任务：全球望远镜、医学图像存储。
  2. 计算密集型任务：科学仿真、金融建模。

---

